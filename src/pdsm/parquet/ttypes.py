#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:dynamic,slots
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
from thrift.protocol.TBase import TBase, TFrozenBase, TExceptionBase, TTransport
all_structs = []


class Type(TBase):
    """
    Types supported by Parquet.  These types are intended to be used in combination
    with the encodings to control the on disk storage format.
    For example INT16 is not included as a type since a good encoding of INT32
    would handle this.
    """
    BOOLEAN = 0
    INT32 = 1
    INT64 = 2
    INT96 = 3
    FLOAT = 4
    DOUBLE = 5
    BYTE_ARRAY = 6
    FIXED_LEN_BYTE_ARRAY = 7

    _VALUES_TO_NAMES = {
        0: "BOOLEAN",
        1: "INT32",
        2: "INT64",
        3: "INT96",
        4: "FLOAT",
        5: "DOUBLE",
        6: "BYTE_ARRAY",
        7: "FIXED_LEN_BYTE_ARRAY",
    }

    _NAMES_TO_VALUES = {
        "BOOLEAN": 0,
        "INT32": 1,
        "INT64": 2,
        "INT96": 3,
        "FLOAT": 4,
        "DOUBLE": 5,
        "BYTE_ARRAY": 6,
        "FIXED_LEN_BYTE_ARRAY": 7,
    }


class ConvertedType(TBase):
    """
    Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
    between types in those frameworks to the base types in parquet.  This is only
    metadata and not needed to read or write the data.
    """
    UTF8 = 0
    MAP = 1
    MAP_KEY_VALUE = 2
    LIST = 3
    ENUM = 4
    DECIMAL = 5
    DATE = 6
    TIME_MILLIS = 7
    TIME_MICROS = 8
    TIMESTAMP_MILLIS = 9
    TIMESTAMP_MICROS = 10
    UINT_8 = 11
    UINT_16 = 12
    UINT_32 = 13
    UINT_64 = 14
    INT_8 = 15
    INT_16 = 16
    INT_32 = 17
    INT_64 = 18
    JSON = 19
    BSON = 20
    INTERVAL = 21

    _VALUES_TO_NAMES = {
        0: "UTF8",
        1: "MAP",
        2: "MAP_KEY_VALUE",
        3: "LIST",
        4: "ENUM",
        5: "DECIMAL",
        6: "DATE",
        7: "TIME_MILLIS",
        8: "TIME_MICROS",
        9: "TIMESTAMP_MILLIS",
        10: "TIMESTAMP_MICROS",
        11: "UINT_8",
        12: "UINT_16",
        13: "UINT_32",
        14: "UINT_64",
        15: "INT_8",
        16: "INT_16",
        17: "INT_32",
        18: "INT_64",
        19: "JSON",
        20: "BSON",
        21: "INTERVAL",
    }

    _NAMES_TO_VALUES = {
        "UTF8": 0,
        "MAP": 1,
        "MAP_KEY_VALUE": 2,
        "LIST": 3,
        "ENUM": 4,
        "DECIMAL": 5,
        "DATE": 6,
        "TIME_MILLIS": 7,
        "TIME_MICROS": 8,
        "TIMESTAMP_MILLIS": 9,
        "TIMESTAMP_MICROS": 10,
        "UINT_8": 11,
        "UINT_16": 12,
        "UINT_32": 13,
        "UINT_64": 14,
        "INT_8": 15,
        "INT_16": 16,
        "INT_32": 17,
        "INT_64": 18,
        "JSON": 19,
        "BSON": 20,
        "INTERVAL": 21,
    }


class FieldRepetitionType(TBase):
    """
    Representation of Schemas
    """
    REQUIRED = 0
    OPTIONAL = 1
    REPEATED = 2

    _VALUES_TO_NAMES = {
        0: "REQUIRED",
        1: "OPTIONAL",
        2: "REPEATED",
    }

    _NAMES_TO_VALUES = {
        "REQUIRED": 0,
        "OPTIONAL": 1,
        "REPEATED": 2,
    }


class Encoding(TBase):
    """
    Encodings supported by Parquet.  Not all encodings are valid for all types.  These
    enums are also used to specify the encoding of definition and repetition levels.
    See the accompanying doc for the details of the more complicated encodings.
    """
    PLAIN = 0
    PLAIN_DICTIONARY = 2
    RLE = 3
    BIT_PACKED = 4
    DELTA_BINARY_PACKED = 5
    DELTA_LENGTH_BYTE_ARRAY = 6
    DELTA_BYTE_ARRAY = 7
    RLE_DICTIONARY = 8

    _VALUES_TO_NAMES = {
        0: "PLAIN",
        2: "PLAIN_DICTIONARY",
        3: "RLE",
        4: "BIT_PACKED",
        5: "DELTA_BINARY_PACKED",
        6: "DELTA_LENGTH_BYTE_ARRAY",
        7: "DELTA_BYTE_ARRAY",
        8: "RLE_DICTIONARY",
    }

    _NAMES_TO_VALUES = {
        "PLAIN": 0,
        "PLAIN_DICTIONARY": 2,
        "RLE": 3,
        "BIT_PACKED": 4,
        "DELTA_BINARY_PACKED": 5,
        "DELTA_LENGTH_BYTE_ARRAY": 6,
        "DELTA_BYTE_ARRAY": 7,
        "RLE_DICTIONARY": 8,
    }


class CompressionCodec(TBase):
    """
    Supported compression algorithms.

    Codecs added in 2.4 can be read by readers based on 2.4 and later.
    Codec support may vary between readers based on the format version and
    libraries available at runtime. Gzip, Snappy, and LZ4 codecs are
    widely available, while Zstd and Brotli require additional libraries.
    """
    UNCOMPRESSED = 0
    SNAPPY = 1
    GZIP = 2
    LZO = 3
    BROTLI = 4
    LZ4 = 5
    ZSTD = 6

    _VALUES_TO_NAMES = {
        0: "UNCOMPRESSED",
        1: "SNAPPY",
        2: "GZIP",
        3: "LZO",
        4: "BROTLI",
        5: "LZ4",
        6: "ZSTD",
    }

    _NAMES_TO_VALUES = {
        "UNCOMPRESSED": 0,
        "SNAPPY": 1,
        "GZIP": 2,
        "LZO": 3,
        "BROTLI": 4,
        "LZ4": 5,
        "ZSTD": 6,
    }


class PageType(TBase):
    DATA_PAGE = 0
    INDEX_PAGE = 1
    DICTIONARY_PAGE = 2
    DATA_PAGE_V2 = 3

    _VALUES_TO_NAMES = {
        0: "DATA_PAGE",
        1: "INDEX_PAGE",
        2: "DICTIONARY_PAGE",
        3: "DATA_PAGE_V2",
    }

    _NAMES_TO_VALUES = {
        "DATA_PAGE": 0,
        "INDEX_PAGE": 1,
        "DICTIONARY_PAGE": 2,
        "DATA_PAGE_V2": 3,
    }


class BoundaryOrder(TBase):
    """
    Enum to annotate whether lists of min/max elements inside ColumnIndex
    are ordered and if so, in which direction.
    """
    UNORDERED = 0
    ASCENDING = 1
    DESCENDING = 2

    _VALUES_TO_NAMES = {
        0: "UNORDERED",
        1: "ASCENDING",
        2: "DESCENDING",
    }

    _NAMES_TO_VALUES = {
        "UNORDERED": 0,
        "ASCENDING": 1,
        "DESCENDING": 2,
    }


class Statistics(TBase):
    """
    Statistics per row group and per page
    All fields are optional.

    Attributes:
     - max: DEPRECATED: min and max value of the column. Use min_value and max_value.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.

    These fields encode min and max values determined by signed comparison
    only. New files should use the correct order for a column's logical type
    and store the values in the min_value and max_value fields.

    To support older readers, these may be set when the column order is
    signed.
     - min
     - null_count: count of null value in the column
     - distinct_count: count of distinct values occurring
     - max_value: Min and max values for the column, determined by its ColumnOrder.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.
     - min_value
    """

    __slots__ = (
        'max',
        'min',
        'null_count',
        'distinct_count',
        'max_value',
        'min_value',
    )


    def __init__(self, max=None, min=None, null_count=None, distinct_count=None, max_value=None, min_value=None,):
        self.max = max
        self.min = min
        self.null_count = null_count
        self.distinct_count = distinct_count
        self.max_value = max_value
        self.min_value = min_value


class StringType(TBase):
    """
    Empty structs to use as logical type annotations
    """

    __slots__ = (
    )



class UUIDType(TBase):

    __slots__ = (
    )



class MapType(TBase):

    __slots__ = (
    )



class ListType(TBase):

    __slots__ = (
    )



class EnumType(TBase):

    __slots__ = (
    )



class DateType(TBase):

    __slots__ = (
    )



class NullType(TBase):
    """
    Logical type to annotate a column that is always null.

    Sometimes when discovering the schema of existing data, values are always
    null and the physical type can't be determined. This annotation signals
    the case where the physical type was guessed from all null values.
    """

    __slots__ = (
    )



class DecimalType(TBase):
    """
    Decimal logical type annotation

    To maintain forward-compatibility in v1, implementations using this logical
    type must also set scale and precision on the annotated SchemaElement.

    Allowed for physical types: INT32, INT64, FIXED, and BINARY

    Attributes:
     - scale
     - precision
    """

    __slots__ = (
        'scale',
        'precision',
    )


    def __init__(self, scale=None, precision=None,):
        self.scale = scale
        self.precision = precision


class MilliSeconds(TBase):
    """
    Time units for logical types
    """

    __slots__ = (
    )



class MicroSeconds(TBase):

    __slots__ = (
    )



class NanoSeconds(TBase):

    __slots__ = (
    )



class TimeUnit(TBase):
    """
    Attributes:
     - MILLIS
     - MICROS
     - NANOS
    """

    __slots__ = (
        'MILLIS',
        'MICROS',
        'NANOS',
    )


    def __init__(self, MILLIS=None, MICROS=None, NANOS=None,):
        self.MILLIS = MILLIS
        self.MICROS = MICROS
        self.NANOS = NANOS


class TimestampType(TBase):
    """
    Timestamp logical type annotation

    Allowed for physical types: INT64

    Attributes:
     - isAdjustedToUTC
     - unit
    """

    __slots__ = (
        'isAdjustedToUTC',
        'unit',
    )


    def __init__(self, isAdjustedToUTC=None, unit=None,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit


class TimeType(TBase):
    """
    Time logical type annotation

    Allowed for physical types: INT32 (millis), INT64 (micros, nanos)

    Attributes:
     - isAdjustedToUTC
     - unit
    """

    __slots__ = (
        'isAdjustedToUTC',
        'unit',
    )


    def __init__(self, isAdjustedToUTC=None, unit=None,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit


class IntType(TBase):
    """
    Integer logical type annotation

    bitWidth must be 8, 16, 32, or 64.

    Allowed for physical types: INT32, INT64

    Attributes:
     - bitWidth
     - isSigned
    """

    __slots__ = (
        'bitWidth',
        'isSigned',
    )


    def __init__(self, bitWidth=None, isSigned=None,):
        self.bitWidth = bitWidth
        self.isSigned = isSigned


class JsonType(TBase):
    """
    Embedded JSON logical type annotation

    Allowed for physical types: BINARY
    """

    __slots__ = (
    )



class BsonType(TBase):
    """
    Embedded BSON logical type annotation

    Allowed for physical types: BINARY
    """

    __slots__ = (
    )



class LogicalType(TBase):
    """
    LogicalType annotations to replace ConvertedType.

    To maintain compatibility, implementations using LogicalType for a
    SchemaElement must also set the corresponding ConvertedType from the
    following table.

    Attributes:
     - STRING
     - MAP
     - LIST
     - ENUM
     - DECIMAL
     - DATE
     - TIME
     - TIMESTAMP
     - INTEGER
     - UNKNOWN
     - JSON
     - BSON
     - UUID
    """

    __slots__ = (
        'STRING',
        'MAP',
        'LIST',
        'ENUM',
        'DECIMAL',
        'DATE',
        'TIME',
        'TIMESTAMP',
        'INTEGER',
        'UNKNOWN',
        'JSON',
        'BSON',
        'UUID',
    )


    def __init__(self, STRING=None, MAP=None, LIST=None, ENUM=None, DECIMAL=None, DATE=None, TIME=None, TIMESTAMP=None, INTEGER=None, UNKNOWN=None, JSON=None, BSON=None, UUID=None,):
        self.STRING = STRING
        self.MAP = MAP
        self.LIST = LIST
        self.ENUM = ENUM
        self.DECIMAL = DECIMAL
        self.DATE = DATE
        self.TIME = TIME
        self.TIMESTAMP = TIMESTAMP
        self.INTEGER = INTEGER
        self.UNKNOWN = UNKNOWN
        self.JSON = JSON
        self.BSON = BSON
        self.UUID = UUID


class SchemaElement(TBase):
    """
    Represents a element inside a schema definition.
     - if it is a group (inner node) then type is undefined and num_children is defined
     - if it is a primitive type (leaf) then type is defined and num_children is undefined
    the nodes are listed in depth first traversal order.

    Attributes:
     - type: Data type for this field. Not set if the current element is a non-leaf node
     - type_length: If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
    Otherwise, if specified, this is the maximum bit length to store any of the values.
    (e.g. a low cardinality INT col could have this set to 3).  Note that this is
    in the schema, and therefore fixed for the entire file.
     - repetition_type: repetition of the field. The root of the schema does not have a repetition_type.
    All other nodes must have one
     - name: Name of the field in the schema
     - num_children: Nested fields.  Since thrift does not support nested fields,
    the nesting is flattened to a single list by a depth-first traversal.
    The children count is used to construct the nested relationship.
    This field is not set when the element is a primitive type
     - converted_type: When the schema is the result of a conversion from another model
    Used to record the original type to help with cross conversion.
     - scale: Used when this column contains decimal data.
    See the DECIMAL converted type for more details.
     - precision
     - field_id: When the original schema supports field ids, this will save the
    original field id in the parquet schema
     - logicalType: The logical type of this SchemaElement

    LogicalType replaces ConvertedType, but ConvertedType is still required
    for some logical types to ensure forward-compatibility in format v1.
    """

    __slots__ = (
        'type',
        'type_length',
        'repetition_type',
        'name',
        'num_children',
        'converted_type',
        'scale',
        'precision',
        'field_id',
        'logicalType',
    )


    def __init__(self, type=None, type_length=None, repetition_type=None, name=None, num_children=None, converted_type=None, scale=None, precision=None, field_id=None, logicalType=None,):
        self.type = type
        self.type_length = type_length
        self.repetition_type = repetition_type
        self.name = name
        self.num_children = num_children
        self.converted_type = converted_type
        self.scale = scale
        self.precision = precision
        self.field_id = field_id
        self.logicalType = logicalType


class DataPageHeader(TBase):
    """
    Data page header

    Attributes:
     - num_values: Number of values, including NULLs, in this data page. *
     - encoding: Encoding used for this data page *
     - definition_level_encoding: Encoding used for definition levels *
     - repetition_level_encoding: Encoding used for repetition levels *
     - statistics: Optional statistics for the data in this page*
    """

    __slots__ = (
        'num_values',
        'encoding',
        'definition_level_encoding',
        'repetition_level_encoding',
        'statistics',
    )


    def __init__(self, num_values=None, encoding=None, definition_level_encoding=None, repetition_level_encoding=None, statistics=None,):
        self.num_values = num_values
        self.encoding = encoding
        self.definition_level_encoding = definition_level_encoding
        self.repetition_level_encoding = repetition_level_encoding
        self.statistics = statistics


class IndexPageHeader(TBase):

    __slots__ = (
    )



class DictionaryPageHeader(TBase):
    """
    TODO: *

    Attributes:
     - num_values: Number of values in the dictionary *
     - encoding: Encoding using this dictionary page *
     - is_sorted: If true, the entries in the dictionary are sorted in ascending order *
    """

    __slots__ = (
        'num_values',
        'encoding',
        'is_sorted',
    )


    def __init__(self, num_values=None, encoding=None, is_sorted=None,):
        self.num_values = num_values
        self.encoding = encoding
        self.is_sorted = is_sorted


class DataPageHeaderV2(TBase):
    """
    New page format allowing reading levels without decompressing the data
    Repetition and definition levels are uncompressed
    The remaining section containing the data is compressed if is_compressed is true


    Attributes:
     - num_values: Number of values, including NULLs, in this data page. *
     - num_nulls: Number of NULL values, in this data page.
    Number of non-null = num_values - num_nulls which is also the number of values in the data section *
     - num_rows: Number of rows in this data page. which means pages change on record boundaries (r = 0) *
     - encoding: Encoding used for data in this page *
     - definition_levels_byte_length: length of the definition levels
     - repetition_levels_byte_length: length of the repetition levels
     - is_compressed: whether the values are compressed.
    Which means the section of the page between
    definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
    is compressed with the compression_codec.
    If missing it is considered compressed
     - statistics: optional statistics for this column chunk
    """

    __slots__ = (
        'num_values',
        'num_nulls',
        'num_rows',
        'encoding',
        'definition_levels_byte_length',
        'repetition_levels_byte_length',
        'is_compressed',
        'statistics',
    )


    def __init__(self, num_values=None, num_nulls=None, num_rows=None, encoding=None, definition_levels_byte_length=None, repetition_levels_byte_length=None, is_compressed=True, statistics=None,):
        self.num_values = num_values
        self.num_nulls = num_nulls
        self.num_rows = num_rows
        self.encoding = encoding
        self.definition_levels_byte_length = definition_levels_byte_length
        self.repetition_levels_byte_length = repetition_levels_byte_length
        self.is_compressed = is_compressed
        self.statistics = statistics


class PageHeader(TBase):
    """
    Attributes:
     - type: the type of the page: indicates which of the *_header fields is set *
     - uncompressed_page_size: Uncompressed page size in bytes (not including this header) *
     - compressed_page_size: Compressed page size in bytes (not including this header) *
     - crc: 32bit crc for the data below. This allows for disabling checksumming in HDFS
    if only a few pages needs to be read

     - data_page_header
     - index_page_header
     - dictionary_page_header
     - data_page_header_v2
    """

    __slots__ = (
        'type',
        'uncompressed_page_size',
        'compressed_page_size',
        'crc',
        'data_page_header',
        'index_page_header',
        'dictionary_page_header',
        'data_page_header_v2',
    )


    def __init__(self, type=None, uncompressed_page_size=None, compressed_page_size=None, crc=None, data_page_header=None, index_page_header=None, dictionary_page_header=None, data_page_header_v2=None,):
        self.type = type
        self.uncompressed_page_size = uncompressed_page_size
        self.compressed_page_size = compressed_page_size
        self.crc = crc
        self.data_page_header = data_page_header
        self.index_page_header = index_page_header
        self.dictionary_page_header = dictionary_page_header
        self.data_page_header_v2 = data_page_header_v2


class KeyValue(TBase):
    """
    Wrapper struct to store key values

    Attributes:
     - key
     - value
    """

    __slots__ = (
        'key',
        'value',
    )


    def __init__(self, key=None, value=None,):
        self.key = key
        self.value = value


class SortingColumn(TBase):
    """
    Wrapper struct to specify sort order

    Attributes:
     - column_idx: The column index (in this row group) *
     - descending: If true, indicates this column is sorted in descending order. *
     - nulls_first: If true, nulls will come before non-null values, otherwise,
    nulls go at the end.
    """

    __slots__ = (
        'column_idx',
        'descending',
        'nulls_first',
    )


    def __init__(self, column_idx=None, descending=None, nulls_first=None,):
        self.column_idx = column_idx
        self.descending = descending
        self.nulls_first = nulls_first


class PageEncodingStats(TBase):
    """
    statistics of a given page type and encoding

    Attributes:
     - page_type: the page type (data/dic/...) *
     - encoding: encoding of the page *
     - count: number of pages of this type with this encoding *
    """

    __slots__ = (
        'page_type',
        'encoding',
        'count',
    )


    def __init__(self, page_type=None, encoding=None, count=None,):
        self.page_type = page_type
        self.encoding = encoding
        self.count = count


class ColumnMetaData(TBase):
    """
    Description for column metadata

    Attributes:
     - type: Type of this column *
     - encodings: Set of all encodings used for this column. The purpose is to validate
    whether we can decode those pages. *
     - path_in_schema: Path in schema *
     - codec: Compression codec *
     - num_values: Number of values in this column *
     - total_uncompressed_size: total byte size of all uncompressed pages in this column chunk (including the headers) *
     - total_compressed_size: total byte size of all compressed pages in this column chunk (including the headers) *
     - key_value_metadata: Optional key/value metadata *
     - data_page_offset: Byte offset from beginning of file to first data page *
     - index_page_offset: Byte offset from beginning of file to root index page *
     - dictionary_page_offset: Byte offset from the beginning of file to first (only) dictionary page *
     - statistics: optional statistics for this column chunk
     - encoding_stats: Set of all encodings used for pages in this column chunk.
    This information can be used to determine if all data pages are
    dictionary encoded for example *
    """

    __slots__ = (
        'type',
        'encodings',
        'path_in_schema',
        'codec',
        'num_values',
        'total_uncompressed_size',
        'total_compressed_size',
        'key_value_metadata',
        'data_page_offset',
        'index_page_offset',
        'dictionary_page_offset',
        'statistics',
        'encoding_stats',
    )


    def __init__(self, type=None, encodings=None, path_in_schema=None, codec=None, num_values=None, total_uncompressed_size=None, total_compressed_size=None, key_value_metadata=None, data_page_offset=None, index_page_offset=None, dictionary_page_offset=None, statistics=None, encoding_stats=None,):
        self.type = type
        self.encodings = encodings
        self.path_in_schema = path_in_schema
        self.codec = codec
        self.num_values = num_values
        self.total_uncompressed_size = total_uncompressed_size
        self.total_compressed_size = total_compressed_size
        self.key_value_metadata = key_value_metadata
        self.data_page_offset = data_page_offset
        self.index_page_offset = index_page_offset
        self.dictionary_page_offset = dictionary_page_offset
        self.statistics = statistics
        self.encoding_stats = encoding_stats


class ColumnChunk(TBase):
    """
    Attributes:
     - file_path: File where column data is stored.  If not set, assumed to be same file as
    metadata.  This path is relative to the current file.

     - file_offset: Byte offset in file_path to the ColumnMetaData *
     - meta_data: Column metadata for this chunk. This is the same content as what is at
    file_path/file_offset.  Having it here has it replicated in the file
    metadata.

     - offset_index_offset: File offset of ColumnChunk's OffsetIndex *
     - offset_index_length: Size of ColumnChunk's OffsetIndex, in bytes *
     - column_index_offset: File offset of ColumnChunk's ColumnIndex *
     - column_index_length: Size of ColumnChunk's ColumnIndex, in bytes *
    """

    __slots__ = (
        'file_path',
        'file_offset',
        'meta_data',
        'offset_index_offset',
        'offset_index_length',
        'column_index_offset',
        'column_index_length',
    )


    def __init__(self, file_path=None, file_offset=None, meta_data=None, offset_index_offset=None, offset_index_length=None, column_index_offset=None, column_index_length=None,):
        self.file_path = file_path
        self.file_offset = file_offset
        self.meta_data = meta_data
        self.offset_index_offset = offset_index_offset
        self.offset_index_length = offset_index_length
        self.column_index_offset = column_index_offset
        self.column_index_length = column_index_length


class RowGroup(TBase):
    """
    Attributes:
     - columns: Metadata for each column chunk in this row group.
    This list must have the same order as the SchemaElement list in FileMetaData.

     - total_byte_size: Total byte size of all the uncompressed column data in this row group *
     - num_rows: Number of rows in this row group *
     - sorting_columns: If set, specifies a sort ordering of the rows in this RowGroup.
    The sorting columns can be a subset of all the columns.
    """

    __slots__ = (
        'columns',
        'total_byte_size',
        'num_rows',
        'sorting_columns',
    )


    def __init__(self, columns=None, total_byte_size=None, num_rows=None, sorting_columns=None,):
        self.columns = columns
        self.total_byte_size = total_byte_size
        self.num_rows = num_rows
        self.sorting_columns = sorting_columns


class TypeDefinedOrder(TBase):
    """
    Empty struct to signal the order defined by the physical or logical type
    """

    __slots__ = (
    )



class ColumnOrder(TBase):
    """
    Union to specify the order used for the min_value and max_value fields for a
    column. This union takes the role of an enhanced enum that allows rich
    elements (which will be needed for a collation-based ordering in the future).

    Possible values are:
    * TypeDefinedOrder - the column uses the order defined by its logical or
                         physical type (if there is no logical type).

    If the reader does not support the value of this union, min and max stats
    for this column should be ignored.

    Attributes:
     - TYPE_ORDER: The sort orders for logical types are:
      UTF8 - unsigned byte-wise comparison
      INT8 - signed comparison
      INT16 - signed comparison
      INT32 - signed comparison
      INT64 - signed comparison
      UINT8 - unsigned comparison
      UINT16 - unsigned comparison
      UINT32 - unsigned comparison
      UINT64 - unsigned comparison
      DECIMAL - signed comparison of the represented value
      DATE - signed comparison
      TIME_MILLIS - signed comparison
      TIME_MICROS - signed comparison
      TIMESTAMP_MILLIS - signed comparison
      TIMESTAMP_MICROS - signed comparison
      INTERVAL - unsigned comparison
      JSON - unsigned byte-wise comparison
      BSON - unsigned byte-wise comparison
      ENUM - unsigned byte-wise comparison
      LIST - undefined
      MAP - undefined

    In the absence of logical types, the sort order is determined by the physical type:
      BOOLEAN - false, true
      INT32 - signed comparison
      INT64 - signed comparison
      INT96 (only used for legacy timestamps) - undefined
      FLOAT - signed comparison of the represented value (*)
      DOUBLE - signed comparison of the represented value (*)
      BYTE_ARRAY - unsigned byte-wise comparison
      FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison

    (*) Because the sorting order is not specified properly for floating
        point values (relations vs. total ordering) the following
        compatibility rules should be applied when reading statistics:
        - If the min is a NaN, it should be ignored.
        - If the max is a NaN, it should be ignored.
        - If the min is +0, the row group may contain -0 values as well.
        - If the max is -0, the row group may contain +0 values as well.
        - When looking for NaN values, min and max should be ignored.
    """

    __slots__ = (
        'TYPE_ORDER',
    )


    def __init__(self, TYPE_ORDER=None,):
        self.TYPE_ORDER = TYPE_ORDER


class PageLocation(TBase):
    """
    Attributes:
     - offset: Offset of the page in the file *
     - compressed_page_size: Size of the page, including header. Sum of compressed_page_size and header
    length
     - first_row_index: Index within the RowGroup of the first row of the page; this means pages
    change on record boundaries (r = 0).
    """

    __slots__ = (
        'offset',
        'compressed_page_size',
        'first_row_index',
    )


    def __init__(self, offset=None, compressed_page_size=None, first_row_index=None,):
        self.offset = offset
        self.compressed_page_size = compressed_page_size
        self.first_row_index = first_row_index


class OffsetIndex(TBase):
    """
    Attributes:
     - page_locations: PageLocations, ordered by increasing PageLocation.offset. It is required
    that page_locations[i].first_row_index < page_locations[i+1].first_row_index.
    """

    __slots__ = (
        'page_locations',
    )


    def __init__(self, page_locations=None,):
        self.page_locations = page_locations


class ColumnIndex(TBase):
    """
    Description for ColumnIndex.
    Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]

    Attributes:
     - null_pages: A list of Boolean values to determine the validity of the corresponding
    min and max values. If true, a page contains only null values, and writers
    have to set the corresponding entries in min_values and max_values to
    byte[0], so that all lists have the same length. If false, the
    corresponding entries in min_values and max_values must be valid.
     - min_values: Two lists containing lower and upper bounds for the values of each page.
    These may be the actual minimum and maximum values found on a page, but
    can also be (more compact) values that do not exist on a page. For
    example, instead of storing ""Blart Versenwald III", a writer may set
    min_values[i]="B", max_values[i]="C". Such more compact values must still
    be valid values within the column's logical type. Readers must make sure
    that list entries are populated before using them by inspecting null_pages.
     - max_values
     - boundary_order: Stores whether both min_values and max_values are orderd and if so, in
    which direction. This allows readers to perform binary searches in both
    lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
    if the lists are ordered.
     - null_counts: A list containing the number of null values for each page *
    """

    __slots__ = (
        'null_pages',
        'min_values',
        'max_values',
        'boundary_order',
        'null_counts',
    )


    def __init__(self, null_pages=None, min_values=None, max_values=None, boundary_order=None, null_counts=None,):
        self.null_pages = null_pages
        self.min_values = min_values
        self.max_values = max_values
        self.boundary_order = boundary_order
        self.null_counts = null_counts


class FileMetaData(TBase):
    """
    Description for file metadata

    Attributes:
     - version: Version of this file *
     - schema: Parquet schema for this file.  This schema contains metadata for all the columns.
    The schema is represented as a tree with a single root.  The nodes of the tree
    are flattened to a list by doing a depth-first traversal.
    The column metadata contains the path in the schema for that column which can be
    used to map columns to nodes in the schema.
    The first element is the root *
     - num_rows: Number of rows in this file *
     - row_groups: Row groups in this file *
     - key_value_metadata: Optional key/value metadata *
     - created_by: String for application that wrote this file.  This should be in the format
    <Application> version <App Version> (build <App Build Hash>).
    e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)

     - column_orders: Sort order used for the min_value and max_value fields of each column in
    this file. Each sort order corresponds to one column, determined by its
    position in the list, matching the position of the column in the schema.

    Without column_orders, the meaning of the min_value and max_value fields is
    undefined. To ensure well-defined behaviour, if min_value and max_value are
    written to a Parquet file, column_orders must be written as well.

    The obsolete min and max fields are always sorted by signed comparison
    regardless of column_orders.
    """

    __slots__ = (
        'version',
        'schema',
        'num_rows',
        'row_groups',
        'key_value_metadata',
        'created_by',
        'column_orders',
    )


    def __init__(self, version=None, schema=None, num_rows=None, row_groups=None, key_value_metadata=None, created_by=None, column_orders=None,):
        self.version = version
        self.schema = schema
        self.num_rows = num_rows
        self.row_groups = row_groups
        self.key_value_metadata = key_value_metadata
        self.created_by = created_by
        self.column_orders = column_orders
all_structs.append(Statistics)
Statistics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'max', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'min', 'BINARY', None, ),  # 2
    (3, TType.I64, 'null_count', None, None, ),  # 3
    (4, TType.I64, 'distinct_count', None, None, ),  # 4
    (5, TType.STRING, 'max_value', 'BINARY', None, ),  # 5
    (6, TType.STRING, 'min_value', 'BINARY', None, ),  # 6
)
all_structs.append(StringType)
StringType.thrift_spec = (
)
all_structs.append(UUIDType)
UUIDType.thrift_spec = (
)
all_structs.append(MapType)
MapType.thrift_spec = (
)
all_structs.append(ListType)
ListType.thrift_spec = (
)
all_structs.append(EnumType)
EnumType.thrift_spec = (
)
all_structs.append(DateType)
DateType.thrift_spec = (
)
all_structs.append(NullType)
NullType.thrift_spec = (
)
all_structs.append(DecimalType)
DecimalType.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'scale', None, None, ),  # 1
    (2, TType.I32, 'precision', None, None, ),  # 2
)
all_structs.append(MilliSeconds)
MilliSeconds.thrift_spec = (
)
all_structs.append(MicroSeconds)
MicroSeconds.thrift_spec = (
)
all_structs.append(NanoSeconds)
NanoSeconds.thrift_spec = (
)
all_structs.append(TimeUnit)
TimeUnit.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'MILLIS', [MilliSeconds, None], None, ),  # 1
    (2, TType.STRUCT, 'MICROS', [MicroSeconds, None], None, ),  # 2
    (3, TType.STRUCT, 'NANOS', [NanoSeconds, None], None, ),  # 3
)
all_structs.append(TimestampType)
TimestampType.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isAdjustedToUTC', None, None, ),  # 1
    (2, TType.STRUCT, 'unit', [TimeUnit, None], None, ),  # 2
)
all_structs.append(TimeType)
TimeType.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isAdjustedToUTC', None, None, ),  # 1
    (2, TType.STRUCT, 'unit', [TimeUnit, None], None, ),  # 2
)
all_structs.append(IntType)
IntType.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'bitWidth', None, None, ),  # 1
    (2, TType.BOOL, 'isSigned', None, None, ),  # 2
)
all_structs.append(JsonType)
JsonType.thrift_spec = (
)
all_structs.append(BsonType)
BsonType.thrift_spec = (
)
all_structs.append(LogicalType)
LogicalType.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'STRING', [StringType, None], None, ),  # 1
    (2, TType.STRUCT, 'MAP', [MapType, None], None, ),  # 2
    (3, TType.STRUCT, 'LIST', [ListType, None], None, ),  # 3
    (4, TType.STRUCT, 'ENUM', [EnumType, None], None, ),  # 4
    (5, TType.STRUCT, 'DECIMAL', [DecimalType, None], None, ),  # 5
    (6, TType.STRUCT, 'DATE', [DateType, None], None, ),  # 6
    (7, TType.STRUCT, 'TIME', [TimeType, None], None, ),  # 7
    (8, TType.STRUCT, 'TIMESTAMP', [TimestampType, None], None, ),  # 8
    None,  # 9
    (10, TType.STRUCT, 'INTEGER', [IntType, None], None, ),  # 10
    (11, TType.STRUCT, 'UNKNOWN', [NullType, None], None, ),  # 11
    (12, TType.STRUCT, 'JSON', [JsonType, None], None, ),  # 12
    (13, TType.STRUCT, 'BSON', [BsonType, None], None, ),  # 13
    (14, TType.STRUCT, 'UUID', [UUIDType, None], None, ),  # 14
)
all_structs.append(SchemaElement)
SchemaElement.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'type_length', None, None, ),  # 2
    (3, TType.I32, 'repetition_type', None, None, ),  # 3
    (4, TType.STRING, 'name', 'UTF8', None, ),  # 4
    (5, TType.I32, 'num_children', None, None, ),  # 5
    (6, TType.I32, 'converted_type', None, None, ),  # 6
    (7, TType.I32, 'scale', None, None, ),  # 7
    (8, TType.I32, 'precision', None, None, ),  # 8
    (9, TType.I32, 'field_id', None, None, ),  # 9
    (10, TType.STRUCT, 'logicalType', [LogicalType, None], None, ),  # 10
)
all_structs.append(DataPageHeader)
DataPageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.I32, 'definition_level_encoding', None, None, ),  # 3
    (4, TType.I32, 'repetition_level_encoding', None, None, ),  # 4
    (5, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 5
)
all_structs.append(IndexPageHeader)
IndexPageHeader.thrift_spec = (
)
all_structs.append(DictionaryPageHeader)
DictionaryPageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.BOOL, 'is_sorted', None, None, ),  # 3
)
all_structs.append(DataPageHeaderV2)
DataPageHeaderV2.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_values', None, None, ),  # 1
    (2, TType.I32, 'num_nulls', None, None, ),  # 2
    (3, TType.I32, 'num_rows', None, None, ),  # 3
    (4, TType.I32, 'encoding', None, None, ),  # 4
    (5, TType.I32, 'definition_levels_byte_length', None, None, ),  # 5
    (6, TType.I32, 'repetition_levels_byte_length', None, None, ),  # 6
    (7, TType.BOOL, 'is_compressed', None, True, ),  # 7
    (8, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 8
)
all_structs.append(PageHeader)
PageHeader.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'uncompressed_page_size', None, None, ),  # 2
    (3, TType.I32, 'compressed_page_size', None, None, ),  # 3
    (4, TType.I32, 'crc', None, None, ),  # 4
    (5, TType.STRUCT, 'data_page_header', [DataPageHeader, None], None, ),  # 5
    (6, TType.STRUCT, 'index_page_header', [IndexPageHeader, None], None, ),  # 6
    (7, TType.STRUCT, 'dictionary_page_header', [DictionaryPageHeader, None], None, ),  # 7
    (8, TType.STRUCT, 'data_page_header_v2', [DataPageHeaderV2, None], None, ),  # 8
)
all_structs.append(KeyValue)
KeyValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)
all_structs.append(SortingColumn)
SortingColumn.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'column_idx', None, None, ),  # 1
    (2, TType.BOOL, 'descending', None, None, ),  # 2
    (3, TType.BOOL, 'nulls_first', None, None, ),  # 3
)
all_structs.append(PageEncodingStats)
PageEncodingStats.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'page_type', None, None, ),  # 1
    (2, TType.I32, 'encoding', None, None, ),  # 2
    (3, TType.I32, 'count', None, None, ),  # 3
)
all_structs.append(ColumnMetaData)
ColumnMetaData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'path_in_schema', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'codec', None, None, ),  # 4
    (5, TType.I64, 'num_values', None, None, ),  # 5
    (6, TType.I64, 'total_uncompressed_size', None, None, ),  # 6
    (7, TType.I64, 'total_compressed_size', None, None, ),  # 7
    (8, TType.LIST, 'key_value_metadata', (TType.STRUCT, [KeyValue, None], False), None, ),  # 8
    (9, TType.I64, 'data_page_offset', None, None, ),  # 9
    (10, TType.I64, 'index_page_offset', None, None, ),  # 10
    (11, TType.I64, 'dictionary_page_offset', None, None, ),  # 11
    (12, TType.STRUCT, 'statistics', [Statistics, None], None, ),  # 12
    (13, TType.LIST, 'encoding_stats', (TType.STRUCT, [PageEncodingStats, None], False), None, ),  # 13
)
all_structs.append(ColumnChunk)
ColumnChunk.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_path', 'UTF8', None, ),  # 1
    (2, TType.I64, 'file_offset', None, None, ),  # 2
    (3, TType.STRUCT, 'meta_data', [ColumnMetaData, None], None, ),  # 3
    (4, TType.I64, 'offset_index_offset', None, None, ),  # 4
    (5, TType.I32, 'offset_index_length', None, None, ),  # 5
    (6, TType.I64, 'column_index_offset', None, None, ),  # 6
    (7, TType.I32, 'column_index_length', None, None, ),  # 7
)
all_structs.append(RowGroup)
RowGroup.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [ColumnChunk, None], False), None, ),  # 1
    (2, TType.I64, 'total_byte_size', None, None, ),  # 2
    (3, TType.I64, 'num_rows', None, None, ),  # 3
    (4, TType.LIST, 'sorting_columns', (TType.STRUCT, [SortingColumn, None], False), None, ),  # 4
)
all_structs.append(TypeDefinedOrder)
TypeDefinedOrder.thrift_spec = (
)
all_structs.append(ColumnOrder)
ColumnOrder.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'TYPE_ORDER', [TypeDefinedOrder, None], None, ),  # 1
)
all_structs.append(PageLocation)
PageLocation.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'offset', None, None, ),  # 1
    (2, TType.I32, 'compressed_page_size', None, None, ),  # 2
    (3, TType.I64, 'first_row_index', None, None, ),  # 3
)
all_structs.append(OffsetIndex)
OffsetIndex.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'page_locations', (TType.STRUCT, [PageLocation, None], False), None, ),  # 1
)
all_structs.append(ColumnIndex)
ColumnIndex.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'null_pages', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'min_values', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'max_values', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I32, 'boundary_order', None, None, ),  # 4
    (5, TType.LIST, 'null_counts', (TType.I64, None, False), None, ),  # 5
)
all_structs.append(FileMetaData)
FileMetaData.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'version', None, None, ),  # 1
    (2, TType.LIST, 'schema', (TType.STRUCT, [SchemaElement, None], False), None, ),  # 2
    (3, TType.I64, 'num_rows', None, None, ),  # 3
    (4, TType.LIST, 'row_groups', (TType.STRUCT, [RowGroup, None], False), None, ),  # 4
    (5, TType.LIST, 'key_value_metadata', (TType.STRUCT, [KeyValue, None], False), None, ),  # 5
    (6, TType.STRING, 'created_by', 'UTF8', None, ),  # 6
    (7, TType.LIST, 'column_orders', (TType.STRUCT, [ColumnOrder, None], False), None, ),  # 7
)
fix_spec(all_structs)
del all_structs
